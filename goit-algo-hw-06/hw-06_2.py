import networkx as nx
import matplotlib.pyplot as plt
from collections import deque

# Список адміністративних центрів України
cities = [
    "Вінниця", "Дніпро", "Донецьк", "Житомир", "Запоріжжя", 
    "Івано-Франківськ", "Київ", "Кропивницький", "Луганськ", "Луцьк", 
    "Львів", "Миколаїв", "Одеса", "Полтава", "Рівне", 
    "Сімферополь", "Суми", "Тернопіль", "Ужгород", "Харків", 
    "Херсон", "Хмельницький", "Черкаси", "Чернівці", "Чернігів"
]

# Матриця відстаней між адміністративними центрами
distances = {
    "Вінниця": {"Житомир": 125, "Київ": 256, "Хмельницький": 120},
    "Дніпро": {"Запоріжжя": 81, "Кропивницький": 294, "Полтава": 196},
    "Донецьк": {"Луганськ": 148, "Запоріжжя": 217, "Дніпро": 252},
    "Житомир": {"Вінниця": 125, "Київ": 131, "Рівне": 187},
    "Запоріжжя": {"Дніпро": 81, "Донецьк": 217, "Кропивницький": 303},
    "Івано-Франківськ": {"Львів": 135, "Тернопіль": 134, "Чернівці": 143},
    "Київ": {"Житомир": 131, "Чернігів": 149, "Вінниця": 256},
    "Кропивницький": {"Дніпро": 294, "Миколаїв": 174, "Запоріжжя": 303},
    "Луганськ": {"Донецьк": 148, "Харків": 333, "Дніпро": 394},
    "Луцьк": {"Львів": 152, "Рівне": 70, "Тернопіль": 159},
    "Львів": {"Луцьк": 152, "Івано-Франківськ": 135, "Тернопіль": 128},
    "Миколаїв": {"Кропивницький": 174, "Одеса": 120, "Херсон": 51},
    "Одеса": {"Миколаїв": 120, "Херсон": 171, "Кропивницький": 294},
    "Полтава": {"Дніпро": 196, "Суми": 261, "Київ": 337},
    "Рівне": {"Луцьк": 70, "Житомир": 187, "Тернопіль": 162},
    "Сімферополь": {"Херсон": 221, "Миколаїв": 282, "Запоріжжя": 365},
    "Суми": {"Харків": 190, "Полтава": 261, "Київ": 346},
    "Тернопіль": {"Львів": 128, "Івано-Франківськ": 134, "Рівне": 162},
    "Ужгород": {"Львів": 261, "Івано-Франківськ": 280, "Тернопіль": 338},
    "Харків": {"Суми": 190, "Полтава": 337, "Дніпро": 213},
    "Херсон": {"Миколаїв": 51, "Сімферополь": 221, "Запоріжжя": 287},
    "Хмельницький": {"Житомир": 120, "Вінниця": 120, "Тернопіль": 112},
    "Черкаси": {"Київ": 190, "Полтава": 324, "Кропивницький": 126},
    "Чернівці": {"Івано-Франківськ": 143, "Тернопіль": 176, "Хмельницький": 190},
    "Чернігів": {"Київ": 149, "Суми": 350, "Житомир": 271}
}

# Створення графу
G = nx.Graph()

# Додавання вершин
for city in cities:
    G.add_node(city)

# Додавання ребер
for city1 in distances:
    for city2 in distances[city1]:
        if city2 in cities:
            G.add_edge(city1, city2, weight=distances[city1][city2])

# Візуалізація графу з круговою розкладкою
plt.figure(figsize=(12, 8))
pos = nx.circular_layout(G)
nx.draw(G, pos, with_labels=True, node_size=500, node_color="skyblue", font_size=10, font_weight="bold")
labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
plt.title("Граф адміністративних центрів України (кругова розкладка)")
plt.show()

# Реалізація DFS за допомогою стека
def dfs(graph, start, goal):
    stack = [(start, [start])]
    best_path = None
    while stack:
        (vertex, path) = stack.pop()
        if vertex == goal:
            if best_path is None or len(path) < len(best_path):
                best_path = path
        for next in set(graph.neighbors(vertex)) - set(path):
            stack.append((next, path + [next]))
    return best_path

# Реалізація BFS за допомогою черги
def bfs(graph, start, goal):
    queue = deque([(start, [start])])
    best_path = None
    while queue:
        (vertex, path) = queue.popleft()
        if vertex == goal:
            if best_path is None or len(path) < len(best_path):
                best_path = path
        for next in set(graph.neighbors(vertex)) - set(path):
            queue.append((next, path + [next]))
    return best_path

# Використання алгоритмів для знаходження шляхів
start_node = "Ужгород"
goal_node = "Чернігів"

dfs_path = dfs(G, start_node, goal_node)
bfs_path = bfs(G, start_node, goal_node)

# Виведення результатів
print("Найкращий шлях, знайдений за допомогою DFS:")
if dfs_path:
    print(" -> ".join(dfs_path))
else:
    print("Шлях не знайдено")

print("\nНайкращий шлях, знайдений за допомогою BFS:")
if bfs_path:
    print(" -> ".join(bfs_path))
else:
    print("Шлях не знайдено")
